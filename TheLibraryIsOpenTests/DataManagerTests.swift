@testable import TheLibraryIsOpen
import XCTest

class DataManagerTests: XCTestCase {

    let database = LocalDatabase()
    var manager: DataManager?
    let testPodcastID: Int = 123
    let testFeedURL = "https://praiadosossos.libsyn.com/rss"

    override func setUpWithError() throws {
        XCTAssertEqual(try database.getPodcastCount(), 0)
        XCTAssertEqual(try database.getEpisodeCount(), 0)
        XCTAssertEqual(try database.getHistoryRecordCount(), 0)
    }

    override func tearDownWithError() throws {
        manager = nil
        XCTAssertNoThrow(try database.deleteAllPodcasts())
        XCTAssertNoThrow(try database.deleteAllEpisodes())
        XCTAssertNoThrow(try database.deleteAllHistoryRecords())
    }

    private func fakePodcastFetch() -> [Podcast] {
        var podcasts = [Podcast]()
        podcasts.append(Podcast(id: testPodcastID, title: "Praia dos Ossos", author: "Rádio Novelo", episodes: nil, feedUrl: testFeedURL, artworkUrl: ""))
        return podcasts
    }

    func test_getEpisodes_whenDoesNotHaveLocalCache_shouldReturnCorrectEpisodeCount() throws {
        // Given that I haven't opened the app before
        let e = expectation(description: "Fetch episodes from remote server")
        var testEpisodes = [Episode]()

        // When I open it
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)

        // Then it fetches all episodes from the remote server
        manager?.getEpisodes(forPodcastID: testPodcastID, feedURL: testFeedURL) { episodes, error in
            guard error == nil else {
                fatalError(error.debugDescription)
            }
            guard let episodes = episodes else {
                return print("Episodes is empty.")
            }
            testEpisodes.append(contentsOf: episodes)
            e.fulfill()
        }

        // And I see a list of episodes for that podcast
        waitForExpectations(timeout: 5.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertEqual(testEpisodes.count, 9)
        }
    }

    func test_getEpisodes_whenHasLocalCache_shouldReturnCorrectEpisodeCount() throws {
        // Given that I have opened the app before
        let e = expectation(description: "Fetch episodes from remote server")
        var testEpisodes = [Episode]()

        try database.insert(podcast: Podcast(id: testPodcastID, title: "Praia dos Ossos", author: "Rádio Novelo", episodes: nil, feedUrl: testFeedURL, artworkUrl: ""))
        try database.insert(episode: Episode(id: "abc", podcastId: testPodcastID, title: "Fake Episode 1", pubDate: Date(), duration: 300, remoteUrl: "", filesize: 0))
        try database.insert(episode: Episode(id: "def", podcastId: testPodcastID, title: "Fake Episode 2", pubDate: Date(), duration: 350, remoteUrl: "", filesize: 0))

        // When I open it
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)

        // Then it fetches all episodes from the local database
        manager?.getEpisodes(forPodcastID: testPodcastID, feedURL: testFeedURL) { episodes, error in
            guard error == nil else {
                fatalError(error.debugDescription)
            }
            guard let episodes = episodes else {
                return print("Episodes is empty.")
            }
            testEpisodes.append(contentsOf: episodes)
            e.fulfill()
        }

        // And I see a list of episodes for that podcast
        waitForExpectations(timeout: 5.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertEqual(testEpisodes.count, 2)
        }
    }
    
    func test_downloadiTunesJSON_wheniTunesAPIQueryURLPassed_shouldDownloadiTunesJSONFile() throws {
        let e = expectation(description: "Fetch podcast details from iTunes server")
        var testFilePath: String = ""
        
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let itunesQueryLink = "https://itunes.apple.com/lookup?id=916378162&entity=podcast"
        
        manager?.downloadiTunesJSON(link: itunesQueryLink, podcastID: 916378162) { filePath, error in
            guard error == nil else {
                fatalError(error!.localizedDescription)
            }
            guard filePath != nil else {
                fatalError()
            }
            guard let url = URL(string: filePath!) else {
                fatalError()
            }
            testFilePath = url.relativePath
            e.fulfill()
        }
        
        waitForExpectations(timeout: 5.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertTrue(testFilePath.contains("/tmp/iTunesAPIRequest_916378162.json"))
        }
    }
    
    func test_getFeedDetails_whenApplePodcastsURLPassed_shouldReturnPodcastFeedURL() throws {
        let e = expectation(description: "Fetch podcast RSS feed")
        var testFeedURL: String = ""
        
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let applePodcastsURL = "https://podcasts.apple.com/br/podcast/um-milkshake-chamado-wanda/id916378162"
        
        try manager?.getFeedDetails(fromLink: applePodcastsURL) { feedDetails, error in
            guard error == nil else {
                fatalError(error!.localizedDescription)
            }
            guard feedDetails != nil else {
                fatalError()
            }
            testFeedURL = feedDetails?.feedUrl ?? ""
            e.fulfill()
        }
        
        waitForExpectations(timeout: 5.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertEqual(testFeedURL, "https://feeds.soundcloud.com/users/soundcloud:users:110149054/sounds.rss")
        }
    }
    
    /*func testGetPodcast() throws {
        let e = expectation(description: "Fetch podcast")
        var testPodcast = Podcast(id: 0)
        
        // Dado que eu abri o app
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        // Então eu vejo a tela Extrair Episódios
        
        // Quando eu informo um link de podcast
        let applePodcastsURL = "https://podcasts.apple.com/br/podcast/um-milkshake-chamado-wanda/id916378162"
        
        // E eu toco em Inspecionar Link
        try manager?.obterPodcast(applePodcastsURL: applePodcastsURL) { podcast, error in
            guard error == nil else {
                fatalError(error!.localizedDescription)
            }
            guard let podcast = podcast else {
                fatalError()
            }
            testPodcast.id = podcast.id
            testPodcast.title = podcast.title
            testPodcast.author = podcast.author
            testPodcast.feedUrl = podcast.feedUrl
            testPodcast.episodes = [Episode]()
            e.fulfill()
        }
        
        // Então eu vejo a tela de detalhes do podcast
        waitForExpectations(timeout: 5.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertEqual(testPodcast.id, 916378162)
            XCTAssertEqual(testPodcast.title, "Um Milkshake Chamado Wanda")
            XCTAssertEqual(testPodcast.author, "Um Milkshake Chamado Wanda")
            XCTAssertEqual(testPodcast.feedUrl, "https://feeds.soundcloud.com/users/soundcloud:users:110149054/sounds.rss")
        }
    }*/
    
    func test_persist_whenPodcastDoesNotExist_shouldNotThrowAnyErrors() throws {
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let podcast = Podcast(id: 1000)
        
        var episodes = [Episode]()
        episodes.append(Episode())
        
        XCTAssertNoThrow(try manager?.persist(podcast: podcast, withEpisodes: episodes))
    }
    
    func test_persist_whenPodcastAlreadyExists_shouldThrowError() throws {
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let podcast = Podcast(id: 1000)
        XCTAssertNoThrow(try database.insert(podcast: podcast))
        
        var episodes = [Episode]()
        episodes.append(Episode())
        
        XCTAssertThrowsError(try manager?.persist(podcast: podcast, withEpisodes: episodes)) { error in
            XCTAssertEqual(error as! DataManagerError, DataManagerError.podcastAlreadyExists)
        }
    }
    
    func test_download_when3EpisodeArrayPassed_shouldDownloadAllEpisodesSuccessfully() throws {
        let e = expectation(description: "Fetch episódios")
        var resultReceptacle: Bool = false
        
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        var episodes = [Episode]()
        episodes.append(Episode(remoteUrl: "http://www.podtrac.com/pts/redirect.mp3/feeds.soundcloud.com/stream/167200434-ummilkshakechamadowanda-celebridades.mp3"))
        episodes.append(Episode(remoteUrl: "http://www.podtrac.com/pts/redirect.mp3/feeds.soundcloud.com/stream/166141695-ummilkshakechamadowanda-um-milkshake-chamado-wanda-02-vazou-foto-nua-na-internet.mp3"))
        episodes.append(Episode(remoteUrl: "http://www.podtrac.com/pts/redirect.mp3/feeds.soundcloud.com/stream/165108622-ummilkshakechamadowanda-01-vma-emmy.mp3"))
        
        // And I tap Inspect Link
        manager?.download(episodeArray: episodes, podcastId: 916378162, progressCallback: { episodeId, fractionCompleted in
            print("Completed \(fractionCompleted)/1.0 of episode \(episodeId)")
        }, completionHandler: { result in
            resultReceptacle = result
            e.fulfill()
        })
        
        // Então eu vejo a tela de detalhes do podcast
        waitForExpectations(timeout: 50.0) { error in
            if let error = error {
                XCTFail("timeout errored: \(error)")
            }
            XCTAssertTrue(resultReceptacle)
        }
    }
    
    // MARK: - Delete Podcast From Archive
    func test_deletePodcastFromArchive_whenPodcastHasManyEpisodes_shouldDeleteAllEpisodes() throws {
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let podcast = Podcast(id: 1000)
        
        var episodes = [Episode]()
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        
        XCTAssertNoThrow(try manager?.persist(podcast: podcast, withEpisodes: episodes))
        
        var podcasts: [Podcast]?
        XCTAssertNoThrow(podcasts = try manager?.getPodcasts())
        
        XCTAssertEqual(podcasts?.count, 1)
        XCTAssertEqual(podcasts?[0].episodes?.count, 10)
        
        XCTAssertNoThrow(try manager?.deletePodcastFromArchive(withId: podcast.id))
        
        XCTAssertNoThrow(podcasts = try manager?.getPodcasts())
        
        XCTAssertEqual(podcasts, nil)
    }
    
    func test_deletePodcastFromArchive_whenPodcastDoesNotExist_shouldThrowError() throws {
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        XCTAssertThrowsError(try manager?.deletePodcastFromArchive(withId: 2000)) { error in
            XCTAssertEqual(error as! LocalDatabaseError, LocalDatabaseError.podcastNotFound)
        }
    }
    
    // MARK: - Podcast History
    func test_getPodcastHistory_whenPodcastJustAdded_shouldReturnOneRecord() throws {
        manager = DataManager(database: database, fetchMethod: fakePodcastFetch)
        
        let podcast = Podcast(id: 123)
        
        var episodes = [Episode]()
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        episodes.append(Episode(podcastId: podcast.id))
        
        XCTAssertNoThrow(try manager?.persist(podcast: podcast, withEpisodes: episodes))
        
        let records = try manager?.getPodcastHistory(from: podcast.id)
        XCTAssertEqual(records?.count, 1)
        
        let firstRecord = records?[0]
        XCTAssertEqual(firstRecord?.title, LocalizableStrings.PodcastHistoryRecord.PodcastArchived.title)
        XCTAssertEqual(firstRecord?.description, "3 episodes added.")
    }

}
